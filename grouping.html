<html>
    <head>
        <title>Frequency Grouping</title>
        <script src = "js/three.min.js"></script>
       	<script src="https://tonejs.github.io/build/Tone.js"></script>
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js" charset="utf-8"></script>
        <link href="https://fonts.googleapis.com/css?family=Poppins&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/grouping.css">
    </head>
    <body>
    	<h1>F R E Q U E N C Y</h1>
    	<h2>TEMPO</h2>
    	<div class="wrapper">
		<div class="switch_box box_1">
			Loop
			<br>
			<input id="checkbox1" type="checkbox" class="switch_1">
		</div>
		</div>
	</div>

    <div class="box">
    <a class="button" href="#popup1">Instructions</a>
    </div>

    <div id="popup1" class="overlay">
        <div class="popup">
            <h3>Instructions</h3>
            <a class="close" href="#">&times;</a>
            <div class="content">
                <center>This is an interactive audiovisual tool that demonstrates the effects of various presentation rates. Click and hold to start the sequence. The cursor's location on the x-axis dictates the starting frequency. The cursor's location on the y-axis dictates it's tempo. Toggle the loop button in the top left to hear it repeat. Start by listening to the sequence at a lower tempo first. The order of the notes should be easily perceived. Now try at a faster tempo. Do any frequency groupings become apparent?</center>
            </div>
        </div>
    </div>
    </body>
</html>
<script> 

	let context = new AudioContext(), mousedown = false, synth, freq, tempo,
    scene, camera, renderer, line, line2, plane, plane2, plane3, plane4, plane5, plane6, plane7, plane8, mouse = {x: 0, y: 0}, text;
 

    let ResetColor = function() {
    	plane.material.color.setHex( 0x0000ff );
    	plane2.material.color.setHex( 0x0000ff );
    	plane3.material.color.setHex( 0x0000ff );
    	plane4.material.color.setHex( 0x0000ff );
    	plane5.material.color.setHex( 0x0000ff );
    	plane6.material.color.setHex( 0x0000ff );
    	plane7.material.color.setHex( 0x0000ff );
    	plane8.material.color.setHex( 0x0000ff );
    };

    let createPlane = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.8)+.2, ((window.innerHeight/window.innerHeight) * -.8) +.2 , 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane.position.copy(pos);


		scene.add( plane );
    };

    let createPlane2 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane2 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.65)+.2, ((window.innerHeight/window.innerHeight) * -.35) +.3, 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane2.position.copy(pos);


		scene.add( plane2 );
    };

    let createPlane3 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane3 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.50)+.2, ((window.innerHeight/window.innerHeight) * -.55) +.225, 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane3.position.copy(pos);

		scene.add( plane3 );
    };

    let createPlane4 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane4 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.35)+.2, ((window.innerHeight/window.innerHeight) * -.8) +.2 , 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane4.position.copy(pos);

		scene.add( plane4 );
    };

    let createPlane5 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane5 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.20)+.2, ((window.innerHeight/window.innerHeight) * .020) +.2 , 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane5.position.copy(pos);


		scene.add( plane5 );
    };

    let createPlane6 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane6 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.05)+.2, ((window.innerHeight/window.innerHeight) * -.55) +.225, 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane6.position.copy(pos);

		scene.add( plane6 );
    };

    let createPlane7 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane7 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * +.10)+.2, ((window.innerHeight/window.innerHeight) * -.35) +.3, 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane7.position.copy(pos);

		scene.add( plane7 );
    };

    let createPlane8 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*5, 10 );
		let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
		plane8 = new THREE.Mesh( geometry, material );

		let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * .25)+.2, ((window.innerHeight/window.innerHeight) * -.55) +.225, 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane8.position.copy(pos);

		scene.add( plane8 );
    };
    
    let createLine = function() {

	    let material = new THREE.LineBasicMaterial( { color: 0xffffff } );
	    let geometry = new THREE.Geometry();
	    geometry.vertices.push(new THREE.Vector3((window.innerWidth/2) * .09, (window.innerHeight/2) * .04, 0));
	    geometry.vertices.push(new THREE.Vector3((window.innerWidth/2) * .09, (window.innerHeight/2) * .08, 0));

	    line = new THREE.Line(geometry, material);

	    // When the mouse moves, call the given function
	    document.addEventListener('mousemove', onMouseMove, false);
    }

    // Follows the mouse event
    function onMouseMove(event) {

        // Update the mouse variable
        event.preventDefault();
        mouse.x = 0;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + .5;

        // Make the sphere follow the mouse
        let vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        line.position.copy(pos);

        scene.add(line);

    };

    let createLine2 = function() {

	    let material = new THREE.LineBasicMaterial( { color: 0xffffff } );
	    let geometry = new THREE.Geometry();
	    geometry.vertices.push(new THREE.Vector3((window.innerWidth/2) * .04, (window.innerHeight/2) * .085, 0));
	    geometry.vertices.push(new THREE.Vector3((window.innerWidth/2) * .0625, (window.innerHeight/2) * .085, 0));

	    line2 = new THREE.Line(geometry, material);

	    // When the mouse moves, call the given function
	    document.addEventListener('mousemove', onMouseMove2, false);
    }

    function onMouseMove2(event) {

        // Update the mouse variable
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 -1.5;
        mouse.y = 0;

        // Make the sphere follow the mouse
        let vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        line2.position.copy(pos);

        scene.add(line2);

    };

    


    // set up the environment - 
    // initiallize scene, camera, objects and renderer
    let init = function() {
        // 1. create the scene
        scene = new THREE.Scene();
    
		camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 500 );
		camera.position.set( 0, 0, 100 );
		camera.lookAt( 0, 0, 0 );

        //let axes = new THREE.AxesHelper(5);
        //   scene.add(axes);
        
        // 3. create and locate the objects on the scene
        createPlane();
        createPlane2();
        createPlane3();
        createPlane4();
        createPlane5();
        createPlane6();
        createPlane7();
        createPlane8();
        createLine();
        createLine2();	

        // 4. create the renderer   
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    };

    // main animation loop - calls every 50-60 ms.
    let mainLoop = function() {

        renderer.render(scene, camera);
        requestAnimationFrame(mainLoop);
    };
 
init();
mainLoop();

//////////////////////////// Audio Code /////////////////////////////

let calculateFrequency = function (mouseXPosition) {
  let minFrequency = 20,
      maxFrequency = 1000;

  return ((mouseXPosition / window.innerWidth) * maxFrequency) + minFrequency;
};

let calculateTempo = function (mouseYPosition) {
  let minTempo = 600,
      maxTempo = 1800;

  return  maxTempo - ((mouseYPosition / window.innerHeight) * maxTempo) + minTempo;
};

let checkBox = document.getElementById("checkbox1");

document.body.addEventListener('mousedown', function (e) {
		function triggerSynth1(){
		synth.triggerAttackRelease(freq*1, '4n');
		ResetColor();
		plane.material.color.setHex( 0xffffff );
	}
		function triggerSynth2(){
		synth.triggerAttackRelease(freq*3, '4n');
		ResetColor();
		plane2.material.color.setHex( 0xffffff );
	}
		function triggerSynth3(){
		synth.triggerAttackRelease(freq*2, '4n');
		ResetColor();
		plane3.material.color.setHex( 0xffffff );
	}
		function triggerSynth4(){
		synth.triggerAttackRelease(freq*1, '4n');
		ResetColor();
		plane4.material.color.setHex( 0xffffff );
	}
		function triggerSynth5(){
		synth.triggerAttackRelease(freq*4, '4n');
		ResetColor();
		plane5.material.color.setHex( 0xffffff );
	}
		function triggerSynth6(){
		synth.triggerAttackRelease(freq*2, '4n');
		ResetColor();
		plane6.material.color.setHex( 0xffffff );
	}
		function triggerSynth7(){
		synth.triggerAttackRelease(freq*3, '4n');
		ResetColor();
		plane7.material.color.setHex( 0xffffff );
	}
		function triggerSynth8(){
		synth.triggerAttackRelease(freq*2, '4n');
		ResetColor();
		plane8.material.color.setHex( 0xffffff );
	}

    mousedown = true;
    freq = calculateFrequency(e.clientX), context.currentTime, 0.01;
    tempo = calculateTempo(e.clientY), context.currentTime, 0.01;
    //create a synth and connect it to the master output (your speakers)
	synth = new Tone.Synth().toMaster()
	Tone.Transport.schedule(triggerSynth1, 0)
	Tone.Transport.schedule(triggerSynth2, 2 * Tone.Time('4n'))
	Tone.Transport.schedule(triggerSynth3, 4 * Tone.Time('4n'))
	Tone.Transport.schedule(triggerSynth4, 6 * Tone.Time('4n'))
	Tone.Transport.schedule(triggerSynth5, 8 * Tone.Time('4n'))
	Tone.Transport.schedule(triggerSynth6, 10 * Tone.Time('4n'))
	Tone.Transport.schedule(triggerSynth7, 12 * Tone.Time('4n'))
	Tone.Transport.schedule(triggerSynth8, 14 * Tone.Time('4n'))

	Tone.Transport.bpm.value = tempo;
    Tone.Transport.toggle();
	Tone.Transport.loopEnd = '4m';

	if (checkBox.checked == true){
		Tone.Transport.loop = true;
	} else {
		Tone.Transport.loop = false;
	};
	
	console.log("Freq: "+freq, "Tempo: "+tempo); 	
});

document.body.addEventListener('mouseup', function () {
  mousedown = false;
  Tone.Transport.toggle();
});





</script>