<html>
    <head>
        <title>Belongingness</title>
        <script src = "js/three.min.js"></script>
        <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js" charset="utf-8"></script>
        <link href="https://fonts.googleapis.com/css?family=Poppins&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/belongingness.css">
    </head>
    <body>

        <div class="wrapper">
        <div class="switch_box box_1">
            Alternate Grouping
            <br>
            <input id="checkbox1" type="checkbox" class="switch_1">
        </div>
        </div>

        <div class="box">
        <a class="button" href="#popup1">Instructions</a>
        </div>

       <div id="popup1" class="overlay">
        <div class="popup">
            <h3>Instructions</h3>
            <a class="close" href="#">&times;</a>
            <div class="content">
                <center>This is a very simple interactive audiovisual example of temporal perceptual grouping, where tones group into pairs because of how close they are to each other (temporally). The 'stillness' is represented by noise. Click and hold to start the audio. Click the toggle in the top left (or press the tab key followed by the spacebar) to contrast this with tones temporally unpaired.</center>
            </div>
        </div>
    </div>
    </body>
</html>
<script>    
"use strict";

let context = new (AudioContext || webkitAudioContext)(), mousedown = false, oscillator, whiteNoise, bufferSize, noiseBuffer, output, scene, camera, renderer, mouse = {x: 0, y: 0}, plane1, plane2, plane3, plane4, plane5, plane6, plane7, plane8, plane9, plane10;

let checkBox = document.getElementById("checkbox1");


let createPlane1 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*2.5, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide} );
        plane1 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.65), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane1.position.copy(pos);


        scene.add( plane1 );
    };

let createPlane2 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide} );
        plane2 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.54), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane2.position.copy(pos);


        scene.add(plane2);
    };


let createPlane3 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide} );
        plane3 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.25), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane3.position.copy(pos);


        scene.add( plane3 );
    };

let createPlane4 = function() {
    let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5, (window.innerHeight/12));
    let material = new THREE.MeshBasicMaterial({color: 0x0000ff, side: THREE.DoubleSide} );
    plane4 = new THREE.Mesh( geometry, material );

    let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * -.15), ((window.innerHeight/window.innerHeight) *.003), 0);
    vector.unproject( camera );
    let dir = vector.sub( camera.position ).normalize();
    let distance = - camera.position.z / dir.z;
    let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
    plane4.position.copy(pos);


    scene.add(plane4);
};


let createPlane5 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5,(window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
        plane5 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * .15), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane5.position.copy(pos);


        scene.add(plane5);
    };

let createPlane6 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
        plane6 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * .25), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane6.position.copy(pos);


        scene.add(plane6);
    };

let createPlane7 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
        plane7 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * .55), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane7.position.copy(pos);


        scene.add(plane7);
    };

let createPlane8 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*1.5, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial( {color: 0x0000ff, side: THREE.DoubleSide} );
        plane8 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3(((window.innerWidth / window.innerWidth) * .65), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane8.position.copy(pos);


        scene.add(plane8);
    };

let createPlane9 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*25, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial( {color: 0x000000, side: THREE.DoubleSide} );
        plane9 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3((window.innerWidth / window.innerWidth)-2, ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane9.position.copy(pos);

        scene.add(plane9);
    };

let createPlane10 = function() {
        let geometry = new THREE.PlaneGeometry((window.innerWidth / window.innerHeight)*24.25, (window.innerHeight/12));
        let material = new THREE.MeshBasicMaterial( {color: 0x000000, side: THREE.DoubleSide} );
        plane10 = new THREE.Mesh( geometry, material );

        let vector = new THREE.Vector3((window.innerWidth / window.innerWidth), ((window.innerHeight/window.innerHeight) *.003), 0);
        vector.unproject( camera );
        let dir = vector.sub( camera.position ).normalize();
        let distance = - camera.position.z / dir.z;
        let pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
        plane10.position.copy(pos);

        scene.add(plane10);
    };




// set up the environment
// initiallize scene, camera, objects and renderer
let init = function() {


    // 1. create the scene
    scene = new THREE.Scene();
    //scene.background = new THREE.Color(0x0000ff);
    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 500 );
    camera.position.set( 0, 0, 100 );
    camera.lookAt( 0, 0, 0 );

    
    // 3. create and locate the objects on the scene
    createPlane1();
    createPlane2();
    createPlane3();
    createPlane4();
    createPlane5();
    createPlane6();
    createPlane7();
    createPlane8();
    createPlane9();
    createPlane10();
    // 4. create the renderer   
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

};

// main animation loop - calls every 50-60 ms.
let mainLoop = function() {

 if (checkBox.checked == true){
        scene.background = new THREE.Color(0x0000ff);
        plane1.material.color.setHex( 0x000000 );
        plane3.material.color.setHex( 0x000000 );
        plane5.material.color.setHex( 0x000000 );
        plane7.material.color.setHex( 0x000000 );
    } else {
        scene.background = new THREE.Color(0x000000);
        plane1.material.color.setHex( 0x0000ff );
        plane3.material.color.setHex( 0x0000ff );
        plane5.material.color.setHex( 0x0000ff );
        plane7.material.color.setHex( 0x0000ff );
    };

    scene.background = new THREE.Color(0x000000);
    /*plane1.material.color.setHex( 0x0000ff );
    plane3.material.color.setHex( 0x0000ff );
    plane5.material.color.setHex( 0x0000ff );
    plane7.material.color.setHex( 0x0000ff );*/

    renderer.render( scene, camera );
    requestAnimationFrame(mainLoop);
};

/////////
init();
mainLoop();

//////////////////////////// Audio Code /////////////////////////////

let gainNode = context.createGain();


document.body.addEventListener('mousedown', function (e) {
    mousedown = true;

    gainNode.gain.setValueAtTime(0.04,context.currentTime);

    if (checkBox.checked == true){
        oscillator = context.createOscillator();
        oscillator.frequency.value = 400;
        oscillator.connect(context.destination);
        oscillator.start(context.currentTime);
        oscillator.frequency.setValueAtTime(0,context.currentTime);
        oscillator.frequency.setValueAtTime(400,context.currentTime+.75);
        oscillator.frequency.setValueAtTime(0,context.currentTime+1);
        oscillator.frequency.setValueAtTime(400,context.currentTime+1.5);
        oscillator.frequency.setValueAtTime(0,context.currentTime+1.75);
        oscillator.frequency.setValueAtTime(400,context.currentTime+2.25);
        oscillator.frequency.setValueAtTime(0,context.currentTime+2.5);
        oscillator.frequency.setValueAtTime(400,context.currentTime+3);
        oscillator.frequency.setValueAtTime(0,context.currentTime+3.25);


        bufferSize = 2 * context.sampleRate,
        noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate),
        output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
        }

        whiteNoise = context.createBufferSource();
        whiteNoise.buffer = noiseBuffer;
        whiteNoise.loop = true;
        whiteNoise.start(0);
        whiteNoise.connect(gainNode);

        gainNode.gain.setValueAtTime(0.01,context.currentTime+.75);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+1);
        gainNode.gain.setValueAtTime(0.01,context.currentTime+1.5);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+1.75);
        gainNode.gain.setValueAtTime(0.01,context.currentTime+2.25);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+2.5);
        gainNode.gain.setValueAtTime(0.01,context.currentTime+3);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+3.25);



    } else {
        oscillator = context.createOscillator();
        oscillator.frequency.value = 400;
        oscillator.connect(context.destination);
        oscillator.start(context.currentTime);
        oscillator.frequency.setValueAtTime(0,context.currentTime);
        oscillator.frequency.setValueAtTime(400,context.currentTime+.75);
        oscillator.frequency.setValueAtTime(0,context.currentTime+.85);
        oscillator.frequency.setValueAtTime(400,context.currentTime+.90);
        oscillator.frequency.setValueAtTime(0,context.currentTime+1);
        oscillator.frequency.setValueAtTime(400,context.currentTime+1.5);
        oscillator.frequency.setValueAtTime(0,context.currentTime+1.6);
        oscillator.frequency.setValueAtTime(400,context.currentTime+1.65);
        oscillator.frequency.setValueAtTime(0,context.currentTime+1.75);
        oscillator.frequency.setValueAtTime(400,context.currentTime+2.25);
        oscillator.frequency.setValueAtTime(0,context.currentTime+2.35);
        oscillator.frequency.setValueAtTime(400,context.currentTime+2.4);
        oscillator.frequency.setValueAtTime(0,context.currentTime+2.5);
        oscillator.frequency.setValueAtTime(400,context.currentTime+3);
        oscillator.frequency.setValueAtTime(0,context.currentTime+3.1);
        oscillator.frequency.setValueAtTime(400,context.currentTime+3.15);
        oscillator.frequency.setValueAtTime(0,context.currentTime+3.25);


        bufferSize = 2 * context.sampleRate,
        noiseBuffer = context.createBuffer(1, bufferSize, context.sampleRate),
        output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
        }

        whiteNoise = context.createBufferSource();
        whiteNoise.buffer = noiseBuffer;
        whiteNoise.loop = true;
        whiteNoise.start(0);
        whiteNoise.connect(gainNode);

        gainNode.gain.setValueAtTime(0.01,context.currentTime+.75);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+1);
        gainNode.gain.setValueAtTime(0.01,context.currentTime+1.5);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+1.75);
        gainNode.gain.setValueAtTime(0.01,context.currentTime+2.25);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+2.5);
        gainNode.gain.setValueAtTime(0.01,context.currentTime+3);
        gainNode.gain.setValueAtTime(0.04,context.currentTime+3.25);

    
    };

    gainNode.connect(context.destination);

});

document.body.addEventListener('mouseup', function () {
    mousedown = false;
    gainNode.gain.setValueAtTime(0.04, context.currentTime);
    oscillator.stop(context.currentTime);
    oscillator.disconnect();
    whiteNoise.stop(0);
    whiteNoise.disconnect();
});




</script>